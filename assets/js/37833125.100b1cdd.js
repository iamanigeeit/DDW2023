"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[1633],{45870:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"oop/oop","title":"Object Oriented Programming","description":"Object-oriented programming (OOP) is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems. OOP plays a crucial role in structuring AI software systems by emphasizing modularity, reusability, and maintenance. In AI, OOP allows developers to create complex systems by defining classes that encapsulate data and behavior, fostering a clear and organized code structure. For instance, in a machine learning project, different components such as data preprocessing, model training, and evaluation can be encapsulated into distinct classes. This modular approach enables developers to reuse code across various projects, enhancing efficiency and reducing redundancy. Additionally, OOP facilitates easier maintenance and scalability of AI systems. When updates or modifications are needed, changes can be made to specific classes without affecting the entire system. For example, if a new algorithm needs to be integrated, it can be added as a new class or method within an existing class, ensuring seamless integration. Furthermore, OOP supports inheritance, allowing new classes to inherit properties and methods from existing ones, promoting code reuse and reducing development time. Overall, OOP provides a robust framework for developing AI systems that are modular, maintainable, and scalable.","source":"@site/docs/04-oop/oop.md","sourceDirName":"04-oop","slug":"/oop/oop","permalink":"/2023/notes/oop/oop","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Week 4: Object-Oriented Paradigm","permalink":"/2023/notes/category/week-4-object-oriented-paradigm"},"next":{"title":"Linear Data Structures","permalink":"/2023/notes/oop/linear-dt"}}');var o=t(74848),i=t(28453),r=(t(28548),t(13358),t(73627)),a=t(53833);const l={sidebar_position:1},d="Object Oriented Programming",c={},h=[{value:"Goals",id:"goals",level:3},{value:"What is Object Oriented Programming?",id:"what-is-object-oriented-programming",level:2},{value:"Attributes and Methods",id:"attributes-and-methods",level:2},{value:"Encapsulation and Properties",id:"encapsulation-and-properties",level:2},{value:"Computed Property",id:"computed-property",level:2},{value:"Composition",id:"composition",level:2},{value:"Special Methods",id:"special-methods",level:2},{value:"UML Diagram",id:"uml-diagram",level:2},{value:"Try it out",id:"try-it-out",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"object-oriented-programming",children:"Object Oriented Programming"})}),"\n",(0,o.jsx)(a.A,{}),"\n",(0,o.jsx)(n.p,{children:"Object-oriented programming (OOP) is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems. OOP plays a crucial role in structuring AI software systems by emphasizing modularity, reusability, and maintenance. In AI, OOP allows developers to create complex systems by defining classes that encapsulate data and behavior, fostering a clear and organized code structure. For instance, in a machine learning project, different components such as data preprocessing, model training, and evaluation can be encapsulated into distinct classes. This modular approach enables developers to reuse code across various projects, enhancing efficiency and reducing redundancy. Additionally, OOP facilitates easier maintenance and scalability of AI systems. When updates or modifications are needed, changes can be made to specific classes without affecting the entire system. For example, if a new algorithm needs to be integrated, it can be added as a new class or method within an existing class, ensuring seamless integration. Furthermore, OOP supports inheritance, allowing new classes to inherit properties and methods from existing ones, promoting code reuse and reducing development time. Overall, OOP provides a robust framework for developing AI systems that are modular, maintainable, and scalable."}),"\n",(0,o.jsx)(n.h3,{id:"goals",children:"Goals"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this lesson, you should be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Use object-oriented programming to ",(0,o.jsx)(n.strong,{children:"abstract data"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Create ",(0,o.jsx)(n.code,{children:"class"})," definitions with initialization and other methods."]}),"\n",(0,o.jsxs)(n.li,{children:["Create ",(0,o.jsx)(n.strong,{children:"stored"})," property and ",(0,o.jsx)(n.strong,{children:"computed"})," property."]}),"\n",(0,o.jsxs)(n.li,{children:["Draw ",(0,o.jsx)(n.strong,{children:"UML class diagram"})," of a class with attributes and methods."]}),"\n",(0,o.jsxs)(n.li,{children:["Explain ",(0,o.jsx)(n.code,{children:"has-a"})," relationship."]}),"\n",(0,o.jsxs)(n.li,{children:["Draw UML class diagram for ",(0,o.jsx)(n.code,{children:"has-a"})," relationship."]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{title:"Keywords",type:"keyword",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"object"}),", ",(0,o.jsx)(n.code,{children:"class"}),", ",(0,o.jsx)(n.code,{children:"instance"}),", ",(0,o.jsx)(n.code,{children:"UML class diagram"}),", ",(0,o.jsx)(n.code,{children:"composition"}),", ",(0,o.jsx)(n.code,{children:"has-a relationship"}),", ",(0,o.jsx)(n.code,{children:"attribute"}),", ",(0,o.jsx)(n.code,{children:"method"}),", ",(0,o.jsx)(n.code,{children:"property"}),", ",(0,o.jsx)(n.code,{children:"stored property"}),", ",(0,o.jsx)(n.code,{children:"computed property"}),", ",(0,o.jsx)(n.code,{children:"getter"}),", ",(0,o.jsx)(n.code,{children:"setter"}),", ",(0,o.jsx)(n.code,{children:"special method"})]})}),"\n",(0,o.jsx)(n.h2,{id:"what-is-object-oriented-programming",children:"What is Object Oriented Programming?"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Object-oriented_programming",children:"Object-oriented programming"}),' (OOP) is a programming paradigm based on the concept of "objects".']}),"\n",(0,o.jsxs)(n.p,{children:["As your program grows in complexity, you may need something more than simple built-in data types such as ",(0,o.jsx)(n.code,{children:"str"}),", ",(0,o.jsx)(n.code,{children:"int"}),", or ",(0,o.jsx)(n.code,{children:"list"}),". For example, when you create a game, you may need an ",(0,o.jsx)(n.code,{children:"Avatar"}),", or ",(0,o.jsx)(n.code,{children:"Weapon"}),", etc. In PowerPoint, you can create a ",(0,o.jsx)(n.code,{children:"Slide"}),", a ",(0,o.jsx)(n.code,{children:"TextBox"}),", a ",(0,o.jsx)(n.code,{children:"Shape"}),", etc. In these cases, it is easier to organize your code around objects. You can think of objects as your own user-defined data types. Later you will see that these objects have two main things:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"attributes"}),": which defines the characteristic of the object, and"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"methods"}),": which defines what the object can do"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Attributes and methods define your object."}),"\n",(0,o.jsxs)(n.p,{children:["You actually have worked with objects if you use ",(0,o.jsx)(n.code,{children:"list"})," and ",(0,o.jsx)(n.code,{children:"str"})," data type in your program. These are ",(0,o.jsx)(n.strong,{children:"built-in"})," objects in Python. Python has provided these objects for you to use. What we will do in this section is to create your own ",(0,o.jsx)(n.strong,{children:"user-defined"})," objects."]}),"\n",(0,o.jsxs)(n.p,{children:["We will see that user-defined objects are made of other data (attributes) and computations (methods). Moreover, we will see that ",(0,o.jsx)(n.strong,{children:"any"})," code can be abstracted as an ",(0,o.jsx)(n.strong,{children:"object"})," since any computer code is made of data (attributes) and some computations (methods). In these lessons, we will see how OOP will be used for both creating user-defined data type as well as for abstracting the whole program."]}),"\n",(0,o.jsx)(n.h2,{id:"attributes-and-methods",children:"Attributes and Methods"}),"\n",(0,o.jsxs)(n.p,{children:["For example, let's say you want to create a computer game with a Robot Turtle as its character. In this case, you may want to define a new data type called ",(0,o.jsx)(n.code,{children:"RobotTurtle"}),". ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," will have the ",(0,o.jsx)(n.strong,{children:"attributes"})," ",(0,o.jsx)(n.code,{children:"speed"})," and ",(0,o.jsx)(n.code,{children:"name"}),". Attributes describes the object and its properties. It is usually a ",(0,o.jsx)(n.em,{children:"noun"})," and it is defined as a kind of variable within the object. On the other hand a Robot Turtle can ",(0,o.jsx)(n.code,{children:"move"}),". So the data type ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," would have a ",(0,o.jsx)(n.strong,{children:"method"})," called ",(0,o.jsx)(n.code,{children:"move"}),". Methods are a kind of functions which apply to our user-defined data type. A method describes what the object can do and so it is usually a ",(0,o.jsx)(n.em,{children:"verb"}),". In order to create our user-defined objects, we have to do the following:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Define a class, which defines the object with its attributes and methods"}),"\n",(0,o.jsx)(n.li,{children:"Instantiate an object, which actually creates the object"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The class definition tells Python about your user-defined object and how to create it. It tells Python what attributes this object has using some existing built-in data types or other defined objects. It tells Python what methods the object can do. But it is important to note that a class definition is just like a kind of contract on a piece of paper. The contract does not create the object. ",(0,o.jsx)(n.em,{children:"Instantiation"})," is the step that actually creates the object in the computer's memory. We will show these two steps below."]}),"\n",(0,o.jsxs)(n.p,{children:["First, let's start by defining our ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," class. Please run the below code (you won't see any output yet, but you will later when there is ",(0,o.jsx)(n.code,{children:"print"}),")."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"# Class definition\nclass RobotTurtle:\n    # Attributes:\n    def __init__(self, name, speed=1):\n        self._name = name\n        self._speed = speed\n        self._pos = (0, 0)\n\n    # Methods:\n    def move(self, direction):\n        update = {'up' : (self._pos[0], self._pos[1] + self._speed),\n                  'down' : (self._pos[0], self._pos[1] - self._speed),\n                  'left' : (self._pos[0] - self._speed, self._pos[1]),\n                  'right' : (self._pos[0] + self._speed, self._pos[1])}\n        self._pos = update[direction]\n\n    def tell_name(self):\n        print(f\"My name is {self._name}\")\n"})}),"\n",(0,o.jsx)(n.p,{children:"Some notes on the class definition:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Notice the above code starts with a ",(0,o.jsx)(n.strong,{children:"Class Definition"}),". To define a class, we use the keyword ",(0,o.jsx)(n.code,{children:"class"})," followed by the class name ",(0,o.jsx)(n.code,{children:"RobotTurtle"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The keyword ",(0,o.jsx)(n.code,{children:"def"})," inside the class defines the ",(0,o.jsx)(n.strong,{children:"method"})," which tells Python what the object can do."]}),"\n",(0,o.jsxs)(n.li,{children:["The first method is special and it is called ",(0,o.jsx)(n.code,{children:"__init__()"}),". This method is always called during ",(0,o.jsx)(n.em,{children:"object instantiation"}),". This special method is called to ",(0,o.jsx)(n.em,{children:"initialize"})," the object's attributes during ",(0,o.jsx)(n.em,{children:"instantiation"}),". In this definition, we see that during instantation, we ask Python to initialize three attributes:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"_name"})," which is a string and is initialized using the first argument during object instantiation."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"_speed"})," which is a number and is initialized using the second optional argument."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"_pos"})," which is the position using a tuple of two numbers and is initalized to ",(0,o.jsx)(n.code,{children:"(0,0)"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["The class definition also contains two other ",(0,o.jsx)(n.strong,{children:"user-defined"})," methods:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"move(direction)"})," which is to move the Robot Turtle to certain direction according to its speed."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tell_name()"})," which is to print out the name of the Robot Turtle."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"It is important to remember that the class definition is just a description of the object and works as a kind of template or contract. The definition does not create the object itself. The object creation happens by doing the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'# Object Instantiation\nmy_robot = RobotTurtle("T1")\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The above line is what we call as ",(0,o.jsx)(n.strong,{children:"object instantiation"}),". When Python executes this lines, it ",(0,o.jsx)(n.em,{children:"instantiates"})," an object of the type ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," in the memory. A few notes on object instantation:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The object is created or ",(0,o.jsx)(n.em,{children:"instantiated"})," by using the class name followed by some values used to initialze the object. In this case: ",(0,o.jsx)(n.code,{children:'RobotTurtle("T1")'}),'. The argument "T1" is passed on to initialize the object\'s name. This object is then pointed to by the variable ',(0,o.jsx)(n.code,{children:"my_robot"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Each of the argument in the ",(0,o.jsx)(n.em,{children:"object instantiation"})," is passed on to the ",(0,o.jsx)(n.code,{children:"__init__()"}),' method. In this case, "T1" is passed on to the formal argument ',(0,o.jsx)(n.code,{children:"name"})," in ",(0,o.jsx)(n.code,{children:"__init__()"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.strong,{children:"first"})," argument of any method in a class is always called ",(0,o.jsx)(n.code,{children:"self"})," following Python's ",(0,o.jsx)(n.a,{href:"https://www.python.org/dev/peps/pep-0008/",children:"PEP8"}),". The ",(0,o.jsx)(n.code,{children:"self"})," argument is also found as the first argument inside the method ",(0,o.jsx)(n.code,{children:"move"})," and ",(0,o.jsx)(n.code,{children:"tell_name"}),". The first argument ",(0,o.jsx)(n.code,{children:"self"})," refers to the particular object instance of the class. It can also be used to access methods and attributes of the current object."]}),"\n",(0,o.jsxs)(n.li,{children:["At the end of object instantiation, the object ",(0,o.jsx)(n.code,{children:"my_robot"})," would have the following attributes initalized:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"_name"})," with a value ",(0,o.jsx)(n.code,{children:"T1"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"_speed"})," with a value of ",(0,o.jsx)(n.code,{children:"1"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"_pos"})," with a value of ",(0,o.jsx)(n.code,{children:"(0,0)"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Once the object is created, we can access its attributes and methods. For example, you can ask the robot to tell its name."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"# Accessing object's method\nmy_robot.tell_name()\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"My name is T1\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"my_robot.tell_name()"})," is calling the method ",(0,o.jsx)(n.code,{children:"tell_name()"})," using the ",(0,o.jsx)(n.strong,{children:"dot operator"}),". To call any method, we use the format of","\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"object.method_name(arguments)\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"You can actually access the attributes directly and change it, for example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"# accessing object's attribute\nprint(my_robot._speed)\nmy_robot._speed = 2\nprint(my_robot._speed)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"1\n2\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["the first and the third line access the object's attribute using the ",(0,o.jsx)(n.strong,{children:"dot operator"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["the second line assigned the value 2 into the object's ",(0,o.jsx)(n.code,{children:"_speed"})," attribute."]}),"\n",(0,o.jsx)(n.li,{children:"if you run the cell above, you will see the speed changes from 1 to 2."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The following examples show more examples on how one can access object's attributes and methods using the dot operator."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"my_robot = RobotTurtle(\"T2\", 2)\n\nprint(f'Robot {my_robot._name} initially at {my_robot._pos}')\nfor _ in range(4):\n    my_robot.move('up')\n    print(f'Robot {my_robot._name} now at {my_robot._pos}')\n    my_robot.move('right')\n    print(f'Robot {my_robot._name} now at {my_robot._pos}')\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"Robot T2 initially at (0, 0)\nRobot T2 now at (0, 2)\nRobot T2 now at (2, 2)\nRobot T2 now at (2, 4)\nRobot T2 now at (4, 4)\nRobot T2 now at (4, 6)\nRobot T2 now at (6, 6)\nRobot T2 now at (6, 8)\nRobot T2 now at (8, 8)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'We create a new object with the name "T2" and speed of 2.'}),"\n",(0,o.jsxs)(n.li,{children:["We first printed its initial position by access ",(0,o.jsx)(n.code,{children:"my_robot._pos"})," attribute."]}),"\n",(0,o.jsxs)(n.li,{children:["Then, we iterate four times. By convention we use ",(0,o.jsx)(n.code,{children:"_"})," when the iteration variable is not needed."]}),"\n",(0,o.jsx)(n.li,{children:"In the iteration, we move up and then move right. After each movement, we print the position."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"encapsulation-and-properties",children:"Encapsulation and Properties"}),"\n",(0,o.jsxs)(n.p,{children:["One important concept of Object-Oriented Programming is  ",(0,o.jsx)(n.strong,{children:"Encapsulation"}),". The idea of encapsulation is that data should be bundled together with some methods to access it. The data itself should be hidden from those outside of the object. With encapsulation, the state of the object is hidden from those outside of the object. If anyone would like to change the state of the object or enquire about the state of the object, it has to do so using some ",(0,o.jsx)(n.strong,{children:"methods"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Why would we want to have this encapsulation? One purpose is ",(0,o.jsx)(n.strong,{children:"abstraction"}),". Anyone working with the object does not need to know how the state or the data inside the object is implemented. For example, we implement the position attribute in our Robot Turtle object as a tuple of two numbers. This assumes those assigning value to this position always assign a tuple with two numbers. What if they don't? Let's illustrate this with an example"]}),"\n",(0,o.jsx)(n.p,{children:"If we let others access the attributes directly, one can assign invalid data into the position attribute, such as the following example."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'my_robot._pos = "This is not supposed to be allowed"\nprint(my_robot._pos)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"This is not supposed to be allowed\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Such assignment should not be allowed in the first place. If it is allowed, then our ",(0,o.jsx)(n.code,{children:"move()"})," method will produce an error now as shown by running the following cell."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'my_robot.move("up")\n'})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:'Traceback (most recent call last):\n  File "2023/notes/oop/oop/#python_script_42287435219288", line 2, in <module>\n    run("""my_robot.move("up")""", \'code_python_8fd2b980_0edd_4e46_81fc_f33f9a605ddd\', 0)\n  File "https://data-driven-world.github.io/2023/bry-libs/brython_runner.py", line 20, in run\n    exec(code, ns)\n  File "<string>", line 1, in <module>\n  File "<string>", line 11, in move\nTypeError: unsupported operand type(s) for +: \'str\' and \'int\'\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Encapsulation also allows us to change the internal data without changing the interface to access the data. In the above example, we store the position as a tuple. But what if we want to use ",(0,o.jsx)(n.em,{children:"list"})," or ",(0,o.jsx)(n.em,{children:"dictionary"})," instead? If we create methods to access these internal data, we can change the internal data without changing the way other objects interact with our data. The key is to keep the interface consistent and stable. We do this by creating methods to access our internal data."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's look at another example of why we want to do encapsulation. Let's say we want to ",(0,o.jsx)(n.em,{children:"update"})," our Robot class definition to implement relative coordinates where the robot has a absolute position and a relative position with respect to some initial position in the map. Let's say, the robot can start at any other position other than ",(0,o.jsx)(n.code,{children:"0, 0"})," and we want to store the absolute position of the robot as its attribute. This change requires a change in the way the programmers set the value of the robot's position since previously the position is always relative to the origin of ",(0,o.jsx)(n.code,{children:"0,0"}),". Such changes may break the code since now the ",(0,o.jsx)(n.code,{children:"_pos"})," attribute means something different. Previously, it is relative to ",(0,o.jsx)(n.code,{children:"0, 0"})," and now it is going to be some absolute position in the map. With encapsulation, however, we can keep the way position is set while changing the internal attributes. For example, we can create ",(0,o.jsx)(n.code,{children:"pos"})," as relative to the initial origin while storing the absolute position internally based on where the initial origin is. Encapsulation simply separates the internal data representation from how others interact with this object. Without encapsulation, we will break the code and require new methods to be created."]}),"\n",(0,o.jsx)(n.p,{children:"To achieve data encapsulation, we usually create two kinds of methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["enquiry or ",(0,o.jsx)(n.em,{children:"getter"}),": this method is used to get or enquire the state of the object"]}),"\n",(0,o.jsxs)(n.li,{children:["modifier or ",(0,o.jsx)(n.em,{children:"setter"}),": this method is used to modify or set the state of the object."]}),"\n"]}),"\n",(0,o.jsx)(r.A,{path:t(82262).A,widthPercentage:"70%"}),"\n",(0,o.jsxs)(n.p,{children:["In Python, we do this using the concept of ",(0,o.jsx)(n.strong,{children:"property"}),". A ",(0,o.jsx)(n.em,{children:"property"})," represents an attribute with its getter and setter. Note that ",(0,o.jsx)(n.strong,{children:"a property is not the same as an attribute"}),". Because they are not the same, Python will require you to use two different names. The name of the property must not be the same as the name of the attribute. Property looks like an attribute but they behave differently. When we set a property's value, it passes through its ",(0,o.jsx)(n.strong,{children:"setter"})," method. Similarly, when we get a property's value, we can only obtain it from its ",(0,o.jsx)(n.strong,{children:"getter"})," method. Since all access passes through some methods, the data is encapsulated by the getter and the setter methods. We can make changes internally without affecting how the outside world interact with the data."]}),"\n",(0,o.jsx)(n.p,{children:"Let's show how we can create a property for position attribute."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"# Class definition\nclass RobotTurtle:\n    # Attributes:\n    def __init__(self, name, speed=1):\n        self._name = name\n        self._speed = speed\n        self._pos = (0, 0)\n\n    #  getter method\n    def get_pos(self):\n        return self._pos\n\n    # Methods:\n    def move(self, direction):\n        update = {'up' : (self.pos[0], self.pos[1] + self.speed),\n                  'down' : (self.pos[0], self.pos[1] - self.speed),\n                  'left' : (self.pos[0] - self.speed, self.pos[1]),\n                  'right' : (self.pos[0] + self.speed, self.pos[1])}\n        self._pos = update[direction]\n\n\n    def tell_name(self):\n        print(f\"My name is {self.name}\")\n        \n    pos = property(get_pos)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Notice the last line of this class definition. We have the following."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"pos = property(get_pos)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This line creates a ",(0,o.jsx)(n.em,{children:"property"})," with the name ",(0,o.jsx)(n.code,{children:"pos"})," using the function ",(0,o.jsx)(n.code,{children:"property()"}),". This function takes in at least one argument which is the ",(0,o.jsx)(n.strong,{children:"getter"})," function. In the case above, our getter function is ",(0,o.jsx)(n.code,{children:"get_pos()"}),". This is defined in the class."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"    #  getter method\n    def get_pos(self):\n        return self._pos\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The function ",(0,o.jsx)(n.code,{children:"property()"})," can take in another argument for the ",(0,o.jsx)(n.strong,{children:"setter"})," function. In our case, our position should not be modified directly and so we do not want to create a setter function for our position data. Our position data should be modified only by the ",(0,o.jsx)(n.code,{children:"move()"})," method. On the other hand, we may want to have setter function for ",(0,o.jsx)(n.code,{children:"name"})," of the robot turtle. We can write the following code snippet."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class RobotTurtle:\n    ...\n    # getter method\n    def get_name(self):\n        return self._name\n        \n    # setter method\n    def set_name(self, value):\n        self._name = value\n        \n    name = property(get_name, set_name)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this case, we created a ",(0,o.jsx)(n.code,{children:"name"})," property that encapsulates the ",(0,o.jsx)(n.code,{children:"_name"})," attribute. To set the data ",(0,o.jsx)(n.code,{children:"_name"}),", one has to use the ",(0,o.jsx)(n.code,{children:"set_name()"})," function. Similarly, to get the data from ",(0,o.jsx)(n.code,{children:"_name"}),", one has to use the ",(0,o.jsx)(n.code,{children:"get_name()"})," function. This may seem pointless, but the getter and setter may contain some logic to it. For example, let's say that we want to make sure only string data is passed to ",(0,o.jsx)(n.code,{children:"_name"}),", we can write:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'    # setter method\n    def set_name(self, value):\n        if isinstance(value, str) and value != "":\n            self._name = value\n'})}),"\n",(0,o.jsx)(n.p,{children:"The above code ensures that the data passed on to our attribute is always a string and non-empty."}),"\n",(0,o.jsxs)(n.p,{children:['Python provides a "shortcut" to create a property using ',(0,o.jsx)(n.strong,{children:"function decorators"}),". This makes the code cleaner and easier to read. The syntax is simple, you just put a decorator ",(0,o.jsx)(n.code,{children:"@property"})," on a getter method of your property. Just make sure that the name of the method is the name of your property. To create the setter, we put another decorator ",(0,o.jsx)(n.code,{children:"@property_name.setter"})," just before our setter function. To rewrite the above code using function decorators, we end up with the following."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class RobotTurtle:\n    ...\n    # getter method\n    @property\n    def name(self):\n        return self._name\n        \n    # setter method\n    @name.setter\n    def name(self, value):\n        if isinstance(value, str) and value != "":\n            self._name = value\n'})}),"\n",(0,o.jsx)(n.p,{children:"Notice a few things here:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We no longer have the line which calls ",(0,o.jsx)(n.code,{children:"property()"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The method name under the decorator ",(0,o.jsx)(n.code,{children:"@property"})," defines the property name."]}),"\n",(0,o.jsxs)(n.li,{children:["By default, a property must have a getter function. The function with the decorator ",(0,o.jsx)(n.code,{children:"@property"})," is the getter method."]}),"\n",(0,o.jsxs)(n.li,{children:["To create the setter, we need to specify which property this setter belongs, so the syntax specifies the name of the property, i.e. ",(0,o.jsx)(n.code,{children:"@name.setter"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In the following section, we will use the syntax using the function decorator instead of calling the ",(0,o.jsx)(n.code,{children:"property()"})," function."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's rewrite our ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," class using property to encapsulate the ",(0,o.jsx)(n.code,{children:"_name"})," attribute and ",(0,o.jsx)(n.code,{children:"_speed"})," attribute. To do this, we are going to create two properties, one for ",(0,o.jsx)(n.code,{children:"name"})," and the other one for ",(0,o.jsx)(n.code,{children:"speed"}),". On the other hand, we will create a property for position only with a getter. The reason is that we want position to be modified only by calling the ",(0,o.jsx)(n.code,{children:"move()"})," method."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"# Class definition\nclass RobotTurtle:\n    # Attributes:\n    def __init__(self, name, speed=1):\n        assert isinstance(name, str) and name\n        self._name = name\n        self._speed = speed\n        self._pos = (0, 0)\n\n    # property getter\n    @property\n    def name(self):\n        return self._name\n\n    # property setter\n    @name.setter\n    def name(self, value):\n        if isinstance(value, str) and value != \"\":\n            self._name = value\n\n    # property getter\n    @property\n    def speed(self):\n        return self._speed\n\n    # property setter\n    @speed.setter\n    def speed(self, value):\n        if isinstance(value, int) and value > 0:\n            self._speed = value\n\n    # property getter\n    @property\n    def pos(self):\n        return self._pos\n\n    # Methods:\n    def move(self, direction):\n        update = {'up' : (self.pos[0], self.pos[1] + self.speed),\n                  'down' : (self.pos[0], self.pos[1] - self.speed),\n                  'left' : (self.pos[0] - self.speed, self.pos[1]),\n                  'right' : (self.pos[0] + self.speed, self.pos[1])}\n        self._pos = update[direction]\n\n\n    def tell_name(self):\n        print(f\"My name is {self.name}\")\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the above, we have a property for ",(0,o.jsx)(n.code,{children:"name"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'    # property getter\n    @property\n    def name(self):\n        return self._name\n\n    # property setter\n    @name.setter\n    def name(self, value):\n        if isinstance(value, str) and value != "":\n            self._name = value\n'})}),"\n",(0,o.jsx)(n.p,{children:"Note:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We use the syntax ",(0,o.jsx)(n.code,{children:"@property"})," to define a getter with the name ",(0,o.jsx)(n.code,{children:"name"}),". This is what is called as ",(0,o.jsx)(n.strong,{children:"decorator"})," in Python. A decorator allows you to modify the function defined in the line just after it. In our case, it changes the method ",(0,o.jsx)(n.code,{children:"def name(self)"})," into a ",(0,o.jsx)(n.strong,{children:"getter"})," method for a property called ",(0,o.jsx)(n.code,{children:"name"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The setter is defined using a decoratory ",(0,o.jsx)(n.code,{children:"@name.setter"}),". In this setter method, we ensure that only those of the type ",(0,o.jsx)(n.code,{children:"str"})," and not empty string can be assigned to the attribute ",(0,o.jsx)(n.code,{children:"_name"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["When you create a ",(0,o.jsx)(n.code,{children:"RobotTurtle"}),", the ",(0,o.jsx)(n.code,{children:"__init__()"})," now has ",(0,o.jsx)(n.code,{children:"self.name = name"})," which will call the setter, since we are operating on the ",(0,o.jsx)(n.strong,{children:"property"})," ",(0,o.jsx)(n.code,{children:"name"})," and not the ",(0,o.jsx)(n.strong,{children:"attribute"})," ",(0,o.jsx)(n.code,{children:"_name"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The property for the ",(0,o.jsx)(n.code,{children:"speed"})," is defined similarly."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"    # property getter\n    @property\n    def speed(self):\n        return self._speed\n\n    # property setter\n    @speed.setter\n    def speed(self, value):\n        if isinstance(value, int) and value > 0:\n            self._speed = value\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The setter decorator is ",(0,o.jsx)(n.code,{children:"@speed.setter"})," where the name before the dot is the name of the ",(0,o.jsx)(n.em,{children:"property"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The setter ensures that only integer greater than 0 can be assigned to the attribute ",(0,o.jsx)(n.code,{children:"_speed"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Let's see some examples on how to use the properties."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'# this is to create a new object with property, make sure you run the cell with the class definition first\nmy_robot = RobotTurtle("T4")\n\n# enquire name and speed\nprint(my_robot.name)\nprint(my_robot.speed)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"T4\n1\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice that you use the property name, which are ",(0,o.jsx)(n.code,{children:"name"})," and ",(0,o.jsx)(n.code,{children:"speed"})," respectively instead of its attributes name, i.e. ",(0,o.jsx)(n.code,{children:"_name"})," and ",(0,o.jsx)(n.code,{children:"_speed"}),". This access calls the ",(0,o.jsx)(n.strong,{children:"getter"})," method of the respective properties."]}),"\n",(0,o.jsxs)(n.p,{children:["Moreover, you can also change the value using the assignment operator which will call the ",(0,o.jsx)(n.strong,{children:"setter"})," method."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'my_robot.name = "T4new"\nprint(my_robot.name)\nmy_robot.name = ""\nprint(my_robot.name)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"T4new\nT4new\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice that in the second assignment, the name is not assigned to an empty string. It remains as ",(0,o.jsx)(n.code,{children:"T4new"}),". The reason is that our setter only assigns the value if the value is a string and non-empty. Similarly, we can see the same behaviour for speed property."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"my_robot.speed = 2\nprint(my_robot.speed)\nmy_robot.speed = -2\nprint(my_robot.speed)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"2\n2\n"})}),"\n",(0,o.jsx)(n.p,{children:"Notice that the second assignment to -2 did not go through because of our setter method's checking."}),"\n",(0,o.jsxs)(n.p,{children:["On the other hand, we do not have any setter for position. The reason is that we want position to always start from ",(0,o.jsx)(n.code,{children:"(0, 0)"})," and it can only change its position through the method ",(0,o.jsx)(n.code,{children:"move()"}),". Note, however, that we are using a ",(0,o.jsx)(n.strong,{children:"single leading underscore"})," as a convention for people not to touch it. We can still enquire the position using the property's getter."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"print(my_robot.pos)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"(0, 0)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To change its position, it should call the ",(0,o.jsx)(n.code,{children:"move()"})," method."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'my_robot.move("up")\nmy_robot.move("up")\nprint(my_robot.pos)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"(0, 4)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note that we use the ",(0,o.jsx)(n.strong,{children:"properties"}),"'s names ",(0,o.jsx)(n.code,{children:"self.pos"})," and ",(0,o.jsx)(n.code,{children:"self.speed"})," in updating the attribute ",(0,o.jsx)(n.code,{children:"_pos"})," and ",(0,o.jsx)(n.code,{children:"_speed"}),". See the ",(0,o.jsx)(n.code,{children:"move()"})," method."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"    def move(self, direction):\n        update = {'up' : (self.pos[0], self.pos[1] + self.speed),\n                  'down' : (self.pos[0], self.pos[1] - self.speed),\n                  'left' : (self.pos[0] - self.speed, self.pos[1]),\n                  'right' : (self.pos[0] + self.speed, self.pos[1])}\n        self._pos = update[direction]\n"})}),"\n",(0,o.jsx)(n.p,{children:"You can actually still access the attributes since Python does not have private attributes. This is how you access the attributes with a leading underscore in its name."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"print(my_robot._pos)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"(0, 4)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["But it is a convention in Python that when you use a single leading underscore, people should not touch it directly. On the other hand, one can also use ",(0,o.jsx)(n.strong,{children:"double leading underscores"}),". This allows ",(0,o.jsx)(n.a,{href:"https://stackoverflow.com/questions/7456807/python-name-mangling",children:"Name Mangling"})," that prevents accidental overloading of methods and name conflicts when you inherit a class."]}),"\n",(0,o.jsx)(n.p,{children:"In summary on the use of leading underscore for attribute's name:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'When in doubt, leave it "public". This means that we should not add anything to obscure the name of your class attribute.'}),"\n",(0,o.jsx)(n.li,{children:'If you really want to send the message "Can\'t touch this!" to your users, the usual way is to precede the variable with one underscore. This is just a convention, but people understand it and take double care when dealing with such stuff.'}),"\n",(0,o.jsx)(n.li,{children:"The double underscore magic is used mainly to avoid accidental overloading of methods and name conflicts with superclasses' attributes. It can be quite useful if you write a class that is expected to be extended many times. We will talk about inheritance to extend a class in the subsequent lessons."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The above summary are taken from ",(0,o.jsx)(n.a,{href:"https://stackoverflow.com/questions/7456807/python-name-mangling",children:"this article"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"computed-property",children:"Computed Property"}),"\n",(0,o.jsxs)(n.p,{children:["Both ",(0,o.jsx)(n.code,{children:"name"})," and ",(0,o.jsx)(n.code,{children:"speed"})," are what is commonly called ",(0,o.jsx)(n.strong,{children:"stored"})," properties. For each stored property there is a corresponding attribute. We can also create what is called ",(0,o.jsx)(n.strong,{children:"computed"})," property. A computed property retrieves its value from some other attributes and does not have a setter. To illustrate, let's create a new user-defined object called ",(0,o.jsx)(n.code,{children:"Coordinate"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"import math\n\nclass Coordinate:\n\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    @property\n    def distance(self):\n        return math.sqrt(self.x * self.x + self.y * self.y)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the above class, we have two attributes ",(0,o.jsx)(n.code,{children:"x"})," and ",(0,o.jsx)(n.code,{children:"y"}),". We do not create any properties for these attributes for simplicity. Python encourages simplicity anyway. But here, we create a computed property called ",(0,o.jsx)(n.code,{children:"distance"}),". This property returns the distance of the current x and y from its origin (0, 0). We can test by instantiating the object and assign some values to its attributes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"# object instantiation\np1 = Coordinate(3, 4)\nprint(p1.x, p1.y)\nprint(p1.distance)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"3 4\n5.0\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The last line prints the computed property ",(0,o.jsx)(n.code,{children:"distance"})," which is computed from the two attributes ",(0,o.jsx)(n.code,{children:"x"})," and ",(0,o.jsx)(n.code,{children:"y"}),". Notice here that ",(0,o.jsx)(n.code,{children:"distance"})," is printed without parentheses and so it is not a ",(0,o.jsx)(n.strong,{children:"method"})," but rather a ",(0,o.jsx)(n.strong,{children:"property"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"So we may ask when we should use a method that returns a value and when to use a computed property. Here are some considerations:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A method can have arguments. This means that if your return value requires some input other than the attributes of its object, you must use a method rather than a computed property."}),"\n",(0,o.jsx)(n.li,{children:"A method describes an action. If the code performs some actions and return the output of that action, then a method is more suitable."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"So when should we use a computed property?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'When the property describes some intrinsic quality of the object. Property is similar in many ways to attribute and it is usually a "noun". It should describe some kind of property of the object rather than some action that the object can do.'}),"\n",(0,o.jsx)(n.li,{children:"When the computation is simple and cheap. We should prefer property for simple values you can get by doing a quick calculation. Distance property in the example above is a good example of this."}),"\n",(0,o.jsxs)(n.li,{children:["When you can compute the value only with the object's attributes. Remember that getter of a property does not take any other argument besides ",(0,o.jsx)(n.code,{children:"self"}),". This means that the computed value must be obtained only from the object's attributes."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"composition",children:"Composition"}),"\n",(0,o.jsxs)(n.p,{children:["An object can be composed of other objects. For example, we have seen that our ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," object is made up of other objects such as ",(0,o.jsx)(n.code,{children:"str"})," for its name, ",(0,o.jsx)(n.code,{children:"int"})," for its speed and tuple for its position. We can also compose an object from other ",(0,o.jsx)(n.strong,{children:"user-defined"})," objects. For example, instead of using a tuple for its position, our Robot Turtle class can use the ",(0,o.jsx)(n.code,{children:"Coordinate"})," class."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"# Class definition\nclass RobotTurtle:\n    # Attributes:\n    def __init__(self, name, speed=1):\n        assert isinstance(name, str) and name\n        self._name = name\n        self._speed = speed\n        self._pos = Coordinate(0, 0)\n\n    # property getter\n    @property\n    def name(self):\n        return self._name\n\n    # property setter\n    @name.setter\n    def name(self, value):\n        if isinstance(value, str) and value != \"\":\n            self._name = value\n\n    # property getter\n    @property\n    def speed(self):\n        return self._speed\n\n    # property setter\n    @speed.setter\n    def speed(self, value):\n        if isinstance(value, int) and value > 0:\n            self._speed = value\n\n    # property getter\n    @property\n    def pos(self):\n        return self._pos\n\n    # Methods:\n    def move(self, direction):\n        update = {'up' : Coordinate(self.pos.x, self.pos.y + self.speed),\n                  'down' : Coordinate(self.pos.x, self.pos.y - self.speed),\n                  'left' : Coordinate(self.pos.x - self.speed, self.pos.y),\n                  'right' : Coordinate(self.pos.x + self.speed, self.pos.y)}\n        self._pos = update[direction]\n\n\n    def tell_name(self):\n        print(f\"My name is {self.name}\")\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We made two main changes. First, in the ",(0,o.jsx)(n.code,{children:"__init__()"})," instead of initializing to a tuple, we instantiate an object ",(0,o.jsx)(n.code,{children:"Coordinate()"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"    def __init__(self, name, speed=1):\n        self._name = name\n        self._speed = speed\n        self._pos = Coordinate(0, 0)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The initial position is still at (0, 0) but now the type is no longer a tuple, but rather, a ",(0,o.jsx)(n.code,{children:"Coordinate"})," class. The second change is on the ",(0,o.jsx)(n.code,{children:"move()"})," method."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"    def move(self, direction):\n        update = {'up' : Coordinate(self.pos.x, self.pos.y + self.speed),\n                  'down' : Coordinate(self.pos.x, self.pos.y - self.speed),\n                  'left' : Coordinate(self.pos.x - self.speed, self.pos.y),\n                  'right' : Coordinate(self.pos.x + self.speed, self.pos.y)}\n        self._pos = update[direction]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Instead of using indices like ",(0,o.jsx)(n.code,{children:"self.pos[0]"})," and ",(0,o.jsx)(n.code,{children:"self.pos[1]"}),", we now use the dot operator with its attribute names like ",(0,o.jsx)(n.code,{children:"self.pos.x"})," and ",(0,o.jsx)(n.code,{children:"self.pos.y"}),". This is much clearer and easier to read as compared to using indices. Moreover, instead of using a tuple, we instantiate ",(0,o.jsx)(n.code,{children:"Coordinate()"})," object as the value of the dictionary ",(0,o.jsx)(n.code,{children:"update"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"We can now create the object and test our new class as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'my_robot = RobotTurtle("T with Coordinate")\nprint(my_robot.pos)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"<exec.Coordinate object>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice that now ",(0,o.jsx)(n.code,{children:"pos"})," is a ",(0,o.jsx)(n.code,{children:"Coordinate"})," object. We can access its attributes as usual."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"print(my_robot.pos.x, my_robot.pos.y)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"0 0\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We can move the robot using the ",(0,o.jsx)(n.code,{children:"move()"})," method."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'my_robot.move("right")\nmy_robot.move("down")\nprint(my_robot.pos.x, my_robot.pos.y)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"1 -1\n"})}),"\n",(0,o.jsx)(n.h2,{id:"special-methods",children:"Special Methods"}),"\n",(0,o.jsxs)(n.p,{children:["Some method names in Python are special and can be overridden. One example of special method that you have encountered is ",(0,o.jsx)(n.code,{children:"__init__()"})," method. This method is always called during object instantiation. There are many other special methods, but for now, we will introduce one more, which is the ",(0,o.jsx)(n.code,{children:"__str__()"})," method. This method is called when Python tries to convert the object to an ",(0,o.jsx)(n.code,{children:"str"})," object. One common instance of this is when you print the object."]}),"\n",(0,o.jsxs)(n.p,{children:["If we print the ",(0,o.jsx)(n.code,{children:"Coordinate()"})," object, we will see the following output."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"p1 = Coordinate(2, 3)\nprint(p1)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Python basically does not understand how to print a ",(0,o.jsx)(n.code,{children:"Coordinate()"}),". But we can tell Python how to convert this object into an ",(0,o.jsx)(n.code,{children:"str"})," which Python can display into the screen. Let's override the method ",(0,o.jsx)(n.code,{children:"__str__()"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'import math\n\nclass Coordinate:\n\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    @property\n    def distance(self):\n        return math.sqrt(self.x * self.x + self.y * self.y)\n\n    def __str__(self):\n        return f"({self.x}, {self.y})"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In the above method ",(0,o.jsx)(n.code,{children:"__str__()"})," we return a string whenever Python tries to convert this object into a string. Once we define this special method, we can print a ",(0,o.jsx)(n.code,{children:"Coordinate"})," object."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"p1 = Coordinate(2, 3)\nprint(p1)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Once ",(0,o.jsx)(n.code,{children:"Coordinate"})," has this method, it can be used whenever the object has some ",(0,o.jsx)(n.code,{children:"Coordinate"})," attributes. For example, we can print our robot position simply by doing the following."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'my_robot = RobotTurtle("T with Coordinate")\nprint(my_robot.pos)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Recall, that previously you have to specify it as"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:"print(my_robot.pos.x, my_robot.pos.y)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["But now it is no longer necessary and Python knows how to convert your ",(0,o.jsx)(n.code,{children:"Coordinate"})," object into a string which can be displayed into the standard output."]}),"\n",(0,o.jsx)(n.h2,{id:"uml-diagram",children:"UML Diagram"}),"\n",(0,o.jsxs)(n.p,{children:["In designing Object Oriented programs, we usually use a ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Class_diagram",children:"UML diagram"}),". UML stands for ",(0,o.jsx)(n.em,{children:"Unified Modeling Language"})," and it gives some specifications how to represent the classes visually. For example, our ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," class is drawn as the following UML class diagram."]}),"\n",(0,o.jsx)(n.mermaid,{value:"classDiagram\nclass RobotTurtle {\n    name\n    speed\n    pos\n    move()\n    tell_name()\n}"}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsx)(n.p,{children:"The UML Class diagram consists of three compartments:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The first compartment on the top: this specifies the class name"}),"\n",(0,o.jsx)(n.li,{children:"The second compartment in the middle: this lists down all the properties and attributes"}),"\n",(0,o.jsx)(n.li,{children:"The third compartment at the bottom: this lists down all the methods"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Sometime, it is useful to identify the property's type especially when there is a case of composition as in our ",(0,o.jsx)(n.code,{children:"pos"})," property. In this case, we know that ",(0,o.jsx)(n.code,{children:"pos"})," is of the type ",(0,o.jsx)(n.code,{children:"Coordinate"}),". This is drawn in UML diagram as follows."]}),"\n",(0,o.jsx)(n.mermaid,{value:"classDiagram\nclass RobotTurtle {\n    name: str\n    speed: int = 1\n    pos: Coordinate\n    move()\n    tell_name()\n}"}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsxs)(n.p,{children:["UML diagrams also allow us to specify the relationship between different classes. For example, ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," and ",(0,o.jsx)(n.code,{children:"Coordinate"})," relationship can be drawn as shown below."]}),"\n",(0,o.jsx)(n.mermaid,{value:"classDiagram\n    RobotTurtle *-- Coordinate\n"}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsxs)(n.p,{children:["In this diagram, we see that one ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," can have one ",(0,o.jsx)(n.code,{children:"Coordinate"}),". This is a specific kind of ",(0,o.jsx)(n.em,{children:"association"})," relationship called ",(0,o.jsx)(n.strong,{children:"composition"}),". This means that ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," is composed of a ",(0,o.jsx)(n.code,{children:"Coordinate"}),". When the object ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," is destroyed, the ",(0,o.jsx)(n.code,{children:"Coordinate"})," object associated with it is also destroyed. There are other kinds of relationship which we will introduce along the way."]}),"\n",(0,o.jsx)(n.h2,{id:"try-it-out",children:"Try it out"}),"\n",(0,o.jsxs)(n.p,{children:["Here's the complete ",(0,o.jsx)(n.code,{children:"RobotTurtle"})," and ",(0,o.jsx)(n.code,{children:"Coordinate"})," class code presented on this page. You are encouraged to explore it."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:"live_py",children:'import math\n\nclass Coordinate:\n\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    @property\n    def distance(self):\n        return math.sqrt(self.x * self.x + self.y * self.y)\n\n    def __str__(self):\n        return f"({self.x}, {self.y})"\n\n# Class definition\nclass RobotTurtle:\n    # Attributes:\n    def __init__(self, name, speed=1):\n        self._name = name\n        self._speed = speed\n        self._pos = Coordinate(0, 0)\n\n    # property getter\n    @property\n    def name(self):\n        return self._name\n\n    # property setter\n    @name.setter\n    def name(self, value):\n        if isinstance(value, str) and value != "":\n            self._name = value\n\n    # property getter\n    @property\n    def speed(self):\n        return self._speed\n\n    # property setter\n    @speed.setter\n    def speed(self, value):\n        if isinstance(value, int) and value > 0:\n            self._speed = value\n\n    # property getter\n    @property\n    def pos(self):\n        return self._pos\n\n    # Methods:\n    def move(self, direction):\n        update = {\'up\' : Coordinate(self.pos.x, self.pos.y + self.speed),\n                  \'down\' : Coordinate(self.pos.x, self.pos.y - self.speed),\n                  \'left\' : Coordinate(self.pos.x - self.speed, self.pos.y),\n                  \'right\' : Coordinate(self.pos.x + self.speed, self.pos.y)}\n        self._pos = update[direction]\n\n\n    def tell_name(self):\n        print(f"My name is {self.name}")\n\n# Test it!\n\nmy_robot = RobotTurtle("T with Coordinate")\nprint(my_robot.pos)\nprint(my_robot.pos.x, my_robot.pos.y)\nmy_robot.move("right")\nmy_robot.move("down")\nprint(my_robot.pos.x, my_robot.pos.y)\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},82262:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/property_attribute-6bffbada27c7ce31a653861dd8eb9a37.png"}}]);